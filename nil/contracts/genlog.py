#!/usr/bin/env python3
import dataclasses
import itertools
import os
import sha3
import sys
from typing import List, Dict, Generator, Union

@dataclasses.dataclass
class Type:
    sol_name: str
    go_name: str
    modifier: str

class Function:
    def __init__(self, params: List[Type]):
        self.params = params
        self.func_id = get_function_selector(self.get_signature())

    def get_solidity_params(self) -> str:
        res = ""
        for i, param in enumerate(self.params):
            res += ", " if i != 0 else ""
            res += f"{param.sol_name} {param.modifier} p{i}"
        return res

    def get_signature(self) -> str:
        return f"log({','.join([p.sol_name for p in self.params])})"

    def func_id_hex(self) -> str:
        return self.func_id

TYPES = [
    Type(sol_name="string", go_name="StringTy", modifier="memory"),
    Type(sol_name="uint256", go_name="Uint256Ty", modifier=""),
    Type(sol_name="bool", go_name="BoolTy", modifier=""),
    Type(sol_name="address", go_name="AddressTy", modifier=""),
]
STRING_TYPE = TYPES[0]
MAX_PARAM_COUNT = 4

def get_function_selector(signature: str) -> str:
    k = sha3.keccak_256()
    k.update(signature.encode('ascii'))
    return k.hexdigest()[:8]

def create_functions() -> List[Function]:
    format_param = STRING_TYPE
    # Pre-append function with no args
    functions: List[Function] = [Function(params=[format_param])]
    for i in range(1, MAX_PARAM_COUNT + 1):
        for p in itertools.product(TYPES, repeat=i):
            f = Function(params=[format_param, *p])
            functions.append(f)
    return functions

def generate_solidity(funcs: List[Function]) -> str:
    solidity_str = """// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

// WARNING: This code was autogenerated using genlog.py.

library console {
    address constant CONSOLE_ADDRESS =
    0x00000000000000000000000000000000000dEBa6;

    function _sendLogPayloadImplementation(bytes memory payload) internal view {
        address consoleAddress = CONSOLE_ADDRESS;
        /// @solidity memory-safe-assembly
        assembly {
            pop(
                staticcall(
                    gas(),
                    consoleAddress,
                    add(payload, 32),
                    mload(payload),
                    0,
                    0
                )
            )
        }
    }

    function _castToPure(
      function(bytes memory) internal view fnIn
    ) internal pure returns (function(bytes memory) pure fnOut) {
        assembly {
            fnOut := fnIn
        }
    }

    function _sendLogPayload(bytes memory payload) internal pure {
        _castToPure(_sendLogPayloadImplementation)(payload);
    }
"""

    for f in funcs:
        s = f"""
    function log({f.get_solidity_params()}) internal pure {{
        _sendLogPayload(abi.encodeWithSignature("{f.get_signature()}", {", ".join(f"p{i}" for i in range(len(f.params)))}));
    }}
"""
        solidity_str += s

    return solidity_str + "}"

def generate_go(funcs: List[Function]) -> str:
    types = "\n\t".join(t.go_name for t in TYPES)
    res = f"""package console

// WARNING: This code was autogenerated using genlog.py.

type ParamType uint8

const (
	NoneTy ParamType = iota
	{types}
)

var LogSignatures = map[uint32][]ParamType{{
"""
    for f in funcs:
        res += f"\t0x{f.func_id_hex()}: {{{', '.join(x.go_name for x in f.params)}}},\n"
    res += "}\n"
    return res


if __name__ == "__main__":
    if len(sys.argv) < 3:
        print("Usage: genlog.py <output_solidity_file> <output_go_file>")
        sys.exit(1)

    funcs = create_functions()
    with open(sys.argv[1], "w") as f:
        f.write(generate_solidity(funcs))
    with open(sys.argv[2], "w") as f:
        f.write(generate_go(funcs))
